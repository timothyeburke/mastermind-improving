//
//  BiasLearner.m
//  MM
//
//  Tim Burke and Tom Davis
//


#import "BiasLearner.h"

// Configure Number of iterations to analyze for learning
#define TEST_LENGTH 10

@implementation BiasLearner

@synthesize numberOfColors;
@synthesize numberOfSlots;
@synthesize taskArguments;
@synthesize biasColors;

- (id)initWithSlots:(int)slots colors:(int)colors {
	if(self = [super init]) {
		self.numberOfColors = colors;
		self.numberOfSlots = slots;
	}
	return self;
}


+ (id)biasLearnerWithSlots:(int)slots colors:(int)colors {
	return [[[BiasLearner alloc] initWithSlots:slots colors:colors] autorelease];
}

- (int)learnBias {
	NSMutableArray *learnArray = [NSMutableArray array];
	
	//  0 - Uniform selection / Unknown Bias
	//  1 - Use exactly one color
	//  2 - Prefer colors with smaller numbers
	//  3 - Cycle through all of the colors in order
	//  4 - Constant # colors != 1, != slots
	int bias0 = 0;
	int bias1 = 0;
	int bias2 = 0;
	int bias3 = 0;
	
	// Remove seed from command arguments, just use the built-in random seed
	NSMutableArray *temp = [NSMutableArray arrayWithArray:self.taskArguments];
	[temp removeObjectAtIndex:3];
	[temp removeObjectAtIndex:3];
	self.taskArguments = [NSArray arrayWithArray:temp];
	
	// Array to hold the number of colors in each game
	int numColors[TEST_LENGTH];
	
	// Loop through a specified number of codes generated by the mmcodes.py
	// and analyze to detect a bias
	for(int a = 0; a < TEST_LENGTH; a++) {
		
		// Setup the external task, run it, and get the code from it
		NSTask *task = [[[NSTask alloc] init] autorelease];
		[task setLaunchPath: @"/usr/bin/python"];
		[task setArguments: self.taskArguments];
		NSPipe *pipe = [NSPipe pipe];
		[task setStandardOutput: pipe];
		NSFileHandle *file = [pipe fileHandleForReading];
		[task launch];
		NSData *data = [file readDataToEndOfFile];
		NSString *string = [[[NSString alloc] initWithData: data encoding: NSUTF8StringEncoding] autorelease];
		learnArray = [NSMutableArray arrayWithArray:[string componentsSeparatedByString: @" "]];
		[learnArray removeLastObject];
		
		// Tag to determine if the bias has been found
		BOOL foundBias = NO;
		
		// test for constant number of colors > 1 && < self.numberOfSlots - bias 4
		int colorsFound = 0;
		NSMutableArray *tempColors = [NSMutableArray array];
		for(int i = 0; i < self.numberOfSlots; i++) {
			NSString *tString = [learnArray objectAtIndex:i];
			if(![tempColors containsObject:tString]) {
				[tempColors addObject:tString];
				colorsFound++;
			}
		}
		numColors[a] = colorsFound;
		
		
		// Test for colors in order - bias 3
		int start = [[learnArray objectAtIndex:0] intValue];
		NSMutableArray *test = [NSMutableArray array];
		for(int i = 0; i < self.numberOfSlots; i++) {
			[test addObject:[NSString stringWithFormat:@"%d", start]];
			start++;
			if(start > self.numberOfColors) {
				start = 1;
			}
		}
		NSString *b3StringTest1 = [test componentsJoinedByString:@" "];
		NSString *b3StringTest2 = [learnArray componentsJoinedByString:@" "];
		if([b3StringTest1 isEqualToString:b3StringTest2]) {
			bias3++;
			foundBias = YES;
		}
		
		// Test for all one color - bias 1
		int c = 0;
		for(int i = 0; i < self.numberOfSlots; i++) {
			c += [[learnArray objectAtIndex:i] intValue];
		}
		if( (((float)c / (float)self.numberOfSlots) == [[learnArray objectAtIndex:0] intValue]) && !foundBias) {
			bias1++;
			foundBias = YES;
		}
		
		// Test for smaller numbers - bias 2
		if(((c / self.numberOfSlots) < ((self.numberOfColors / 2) + 0)) && !foundBias) {
			bias2++;
			foundBias = YES;
		}
		
		if(!foundBias) {
			bias0++;
		}
	}
	
	// Complete test for constant number of colors
	BOOL constantColors = YES;
	for(int a = 0; a < (TEST_LENGTH - 1); a++) {
		if (numColors[a] == numColors[a+1]) {
			continue;
		} else {
			constantColors = NO;
			break;
		}

	}
	if(constantColors && numColors[0] != 1 && numColors[0] != self.numberOfSlots) {
		self.biasColors = numColors[0];
		return 4;
	}
	
	// Test for greatest represented bias other than 4
	if(bias1 > bias0 && bias1 > bias2 && bias1 > bias3) {
		return 1;
	}
	if(bias2 > bias0 && bias2 > bias1 && bias2 > bias3) {
		return 2;
	}
	if(bias3 > bias0 && bias3 > bias1 && bias3 > bias2) {
		return 3;
	}
	
	// If no bias was found or understood, use standard distribution
	return 0;
}

@end
